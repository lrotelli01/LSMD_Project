\chapter{Implementation}

\section{Technology Stack}

The \textbf{LargeB\&B} application has been developed using a modern technology stack based on Java and Spring Boot, leveraging a polyglot persistence architecture that combines three different database systems to optimize data management and query performance.

\subsection{Spring Boot Framework}

The backend is built with \textbf{Spring Boot 3.2.0}, a powerful framework for building production-ready applications. Spring Boot provides:

\begin{itemize}
    \item \textbf{Dependency Injection}: Automatic management of component dependencies
    \item \textbf{Auto-configuration}: Simplified configuration of database connections and services
    \item \textbf{RESTful API}: Native support for building REST APIs
    \item \textbf{Security}: Integrated Spring Security for authentication and authorization
\end{itemize}

The main dependencies defined in \texttt{pom.xml} include:

\begin{minted}[fontsize=\small]{xml}
<dependencies>
    <!-- Spring Boot Starters -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Database Integrations -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-mongodb</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-neo4j</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- Security & JWT -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version>
    </dependency>
    
    <!-- API Documentation -->
    <dependency>
        <groupId>org.springdoc</groupId>
        <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        <version>2.3.0</version>
    </dependency>
    
    <!-- Utilities -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
\end{minted}

\subsection{Polyglot Persistence Architecture}

LargeB\&B implements a \textbf{polyglot persistence} approach, utilizing three different database systems, each optimized for specific use cases:

\begin{itemize}
    \item \textbf{MongoDB} (Port 27017): Document-oriented database for operational data (users, properties, reservations, reviews)
    \item \textbf{Neo4j} (Port 7687): Graph database for collaborative filtering and recommendation systems
    \item \textbf{Redis} (Port 6379): In-memory cache for trending properties and session management
\end{itemize}

The database configuration is centralized in \texttt{application.properties}:

\begin{minted}[fontsize=\small]{properties}
# MongoDB Configuration
spring.data.mongodb.database=large_bnb_db
spring.data.mongodb.uri=mongodb://localhost:27017/large_bnb_db

# Neo4j Configuration
spring.neo4j.uri=bolt://localhost:7687
spring.neo4j.authentication.username=neo4j
spring.neo4j.authentication.password=Carota123!

# Redis Configuration
spring.data.redis.host=localhost
spring.data.redis.port=6379

# JWT Configuration
jwt.secret=e92f87b4a1c5d6e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2!
jwt.expiration=3600000
\end{minted}

\section{Model Layer}

The model layer defines the domain entities and their mapping to the respective databases. Following the MVC (Model-View-Controller) pattern, the models represent the core business logic of the application.

\subsection{MongoDB Models}

MongoDB models use the \texttt{@Document} annotation to map Java classes to MongoDB collections. The models leverage Lombok annotations to reduce boilerplate code.

\subsubsection{User Models}

The user hierarchy is implemented using inheritance, with \texttt{RegisteredUser} as an abstract base class:

\begin{minted}[fontsize=\small]{java}
@Data
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "users")
public abstract class RegisteredUser {
    @Id
    private String id;
    
    private String username;
    private String email;
    private String password;
    private LocalDate birthdate;
    private String name;
    private String surname;
    private String phoneNumber;
    private String role; // "CUSTOMER" or "MANAGER"
}
\end{minted}

The \texttt{Customer} class extends \texttt{RegisteredUser} with additional fields:

\begin{minted}[fontsize=\small]{java}
@Data
@EqualsAndHashCode(callSuper = true)
public class Customer extends RegisteredUser {
    private PaymentMethod paymentMethod;
    private Set<String> favoredPropertyIds;
}
\end{minted}

The \texttt{Manager} class is similarly structured but with business-specific attributes:

\begin{minted}[fontsize=\small]{java}
@Data
@EqualsAndHashCode(callSuper = true)
public class Manager extends RegisteredUser {
    private String iban;
    private String vatNumber;
    private BillingAddress billingAddress;
}
\end{minted}

\subsubsection{Property Model}

The \texttt{Property} model demonstrates advanced MongoDB features including embedded documents, compound indexes, text indexes, and geospatial indexes:

\begin{minted}[fontsize=\small]{java}
@Data
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "properties")
@CompoundIndexes({
    @CompoundIndex(name = "location_idx", 
                   def = "{'city': 1, 'region': 1, 'country': 1}"),
    @CompoundIndex(name = "room_capacity_idx", 
                   def = "{'rooms.capacityAdults': 1, 'rooms.capacityChildren': 1}"),
    @CompoundIndex(name = "rating_sort_idx", 
                   def = "{'ratingStats.value': -1}")
})
public class Property {
    @Id
    private String id;
    
    @TextIndexed(weight = 3)
    private String name;
    
    @TextIndexed
    private String description;
    
    @TextIndexed
    private String city;
    
    @Indexed
    private String managerId;
    
    @GeoSpatialIndexed(type = GeoSpatialIndexType.GEO_2DSPHERE)
    private List<Double> coordinates; // [longitude, latitude]
    
    private List<String> amenities;
    private List<String> photos;
    private String country;
    private String region;
    
    // Embedded documents
    private List<Room> rooms;
    private List<PointOfInterest> pois;
    private RatingStats ratingStats;
}
\end{minted}

Key design decisions:

\begin{itemize}
    \item \textbf{Embedded Rooms}: Rooms are embedded within properties for atomic updates and faster retrieval
    \item \textbf{Text Indexes}: Enable full-text search on property names and descriptions with weighted relevance
    \item \textbf{Geospatial Index}: Supports proximity queries for "find properties near me" functionality
    \item \textbf{Compound Indexes}: Optimize common filter combinations (location hierarchy, room capacity, rating sorting)
\end{itemize}

\subsubsection{Reservation Model}

The \texttt{Reservation} model includes critical compound indexes for availability checking:

\begin{minted}[fontsize=\small]{java}
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "reservations")
@CompoundIndex(name = "room_availability_idx", 
               def = "{'roomId': 1, 'dates.checkIn': 1, 'dates.checkOut': 1}")
public class Reservation {
    @Id
    private String id;
    
    private Integer adults;
    private Integer children;
    private String status;
    
    @Indexed
    private String userId;
    
    @Indexed
    private String roomId;
    
    private ReservationDates dates;
    
    @CreatedDate
    private LocalDateTime createdAt;
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ReservationDates {
        @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
        private LocalDate checkIn;
        
        @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
        private LocalDate checkOut;
    }
}
\end{minted}

The compound index on \texttt{roomId}, \texttt{checkIn}, and \texttt{checkOut} is critical for efficiently querying room availability: "Is Room X free between Date A and Date B?"

\subsubsection{Review Model}

Reviews are stored in a separate collection to enable flexible querying and pagination:

\begin{minted}[fontsize=\small]{java}
@Data
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "reviews")
public class Review {
    @Id
    private String id;
    
    private String userId;
    private String username;
    
    @Indexed
    private String propertyId;
    
    private Double rating;
    private Double cleanliness;
    private Double communication;
    private Double location;
    private Double value;
    
    private String comment;
    private LocalDateTime creationDate;
}
\end{minted}

\subsection{Neo4j Models}

Neo4j models use the \texttt{@Node} annotation and define graph relationships using \texttt{@Relationship}. The graph database is optimized for social features and collaborative filtering.

\subsubsection{User Node}

\begin{minted}[fontsize=\small]{java}
@Node("User")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserNode {
    @Id
    @GeneratedValue
    private Long graphId;
    
    private String userId;
    private String username;
    private String privacyStatus;
}
\end{minted}

\subsubsection{Property Node}

\begin{minted}[fontsize=\small]{java}
@Node("Property")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PropertyNode {
    @Id
    @GeneratedValue
    private Long graphId;
    
    private String propertyId;
    private String name;
    private String city;
}
\end{minted}

\subsubsection{Booking Relationship}

The \texttt{BOOKED} relationship connects users to properties they have reserved:

\begin{minted}[fontsize=\small]{java}
@RelationshipProperties
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BookedRelationship {
    @Id
    @GeneratedValue
    private Long id;
    
    private LocalDate date;
    
    @TargetNode
    private PropertyNode property;
}
\end{minted}

This graph structure enables powerful collaborative filtering queries such as: "Users who booked property X also booked properties Y and Z."

\subsection{Utility Classes}

\subsubsection{RatingStats}

Aggregate statistics for property ratings:

\begin{minted}[fontsize=\small]{java}
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RatingStats {
    private Double cleanliness;
    private Double communication;
    private Double location;
    private Double value;
}
\end{minted}

\subsubsection{PaymentMethod}

Secure payment information storage:

\begin{minted}[fontsize=\small]{java}
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaymentMethod {
    private String id;
    private String gatewayToken;  // Tokenized, not storing actual card numbers
    private String cardType;      // "VISA", "MASTERCARD", etc.
    private String last4Digits;
    private String expiryDate;
    private String cardHolderName;
}
\end{minted}

\section{Repository Layer}

The repository layer provides data access abstraction using Spring Data repositories. This layer handles all database operations without requiring boilerplate SQL/Cypher code.

\subsection{MongoDB Repositories}

Spring Data MongoDB provides automatic query generation based on method names:

\begin{minted}[fontsize=\small]{java}
public interface UserRepository extends MongoRepository<RegisteredUser, String> {
    Optional<RegisteredUser> findByEmail(String email);
    Optional<RegisteredUser> findByUsername(String username);
    boolean existsByEmail(String email);
    boolean existsByUsername(String username);
}
\end{minted}

\begin{minted}[fontsize=\small]{java}
public interface PropertyRepository extends MongoRepository<Property, String> {
    List<Property> findByManagerId(String managerId);
    List<Property> findByCity(String city);
    
    @Query("{ 'name': { $regex: ?0, $options: 'i' } }")
    List<Property> searchByName(String name);
}
\end{minted}

\begin{minted}[fontsize=\small]{java}
public interface ReservationRepository extends MongoRepository<Reservation, String> {
    List<Reservation> findByUserId(String userId);
    List<Reservation> findByRoomIdIn(List<String> roomIds);
    List<Reservation> findByStatus(String status);
    
    @Query("{ 'roomId': ?0, $or: [ " +
           "{ 'dates.checkIn': { $lte: ?2 }, 'dates.checkOut': { $gte: ?1 } }, " +
           "{ 'dates.checkIn': { $gte: ?1, $lte: ?2 } } ] }")
    List<Reservation> findConflictingReservations(String roomId, 
                                                   LocalDate checkIn, 
                                                   LocalDate checkOut);
}
\end{minted}

The \texttt{findConflictingReservations} method is crucial for availability checking, ensuring no double-booking occurs.

\subsection{Neo4j Repositories}

Neo4j repositories leverage Cypher queries for graph traversals:

\begin{minted}[fontsize=\small]{java}
public interface UserNodeRepository extends Neo4jRepository<UserNode, Long> {
    Optional<UserNode> findByUserId(String userId);
    
    @Query("MATCH (u:User {userId: $userId})-[:BOOKED]->(p:Property) " +
           "RETURN p.propertyId")
    List<String> findBookedPropertyIds(String userId);
}
\end{minted}

\begin{minted}[fontsize=\small]{java}
public interface PropertyNodeRepository extends Neo4jRepository<PropertyNode, Long> {
    Optional<PropertyNode> findByPropertyId(String propertyId);
}
\end{minted}

\section{Service Layer}

The service layer implements the business logic, orchestrating operations across multiple databases and ensuring data consistency.

\subsection{Authentication Services}

\subsubsection{LoginService}

Handles user authentication and JWT token generation:

\begin{minted}[fontsize=\small]{java}
@Service
@RequiredArgsConstructor
public class LoginService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;
    
    public LoginResponseDTO login(LoginRequestDTO request) {
        RegisteredUser user = userRepository.findByEmail(request.getEmail())
            .orElseThrow(() -> new IllegalArgumentException("Invalid credentials"));
        
        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new IllegalArgumentException("Invalid credentials");
        }
        
        String token = jwtUtil.generateToken(user.getEmail(), user.getRole());
        
        return LoginResponseDTO.builder()
            .token(token)
            .userId(user.getId())
            .username(user.getUsername())
            .role(user.getRole())
            .build();
    }
}
\end{minted}

\subsubsection{RegistrationService}

Manages user registration with password hashing:

\begin{minted}[fontsize=\small]{java}
@Service
@RequiredArgsConstructor
public class RegistrationService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    public RegistrationResponseDTO registerCustomer(RegistrationRequestDTO request) {
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new IllegalArgumentException("Email already registered");
        }
        
        Customer customer = new Customer();
        customer.setEmail(request.getEmail());
        customer.setUsername(request.getUsername());
        customer.setPassword(passwordEncoder.encode(request.getPassword()));
        customer.setName(request.getName());
        customer.setSurname(request.getSurname());
        customer.setRole("CUSTOMER");
        customer.setFavoredPropertyIds(new HashSet<>());
        
        Customer saved = (Customer) userRepository.save(customer);
        
        return RegistrationResponseDTO.builder()
            .userId(saved.getId())
            .message("Registration successful")
            .build();
    }
}
\end{minted}

\subsection{PropertyService}

Implements advanced search, filtering, and geospatial queries:

\begin{minted}[fontsize=\small]{java}
@Service
@RequiredArgsConstructor
public class PropertyService {
    private final PropertyRepository propertyRepository;
    private final MongoTemplate mongoTemplate;
    private final RedisTemplate<String, Object> redisTemplate;
    
    public List<PropertyResponseDTO> searchProperties(String city, 
                                                       Double minPrice, 
                                                       Double maxPrice, 
                                                       List<String> amenities) {
        Query query = new Query();
        
        if (city != null && !city.trim().isEmpty()) {
            query.addCriteria(Criteria.where("city").regex(city, "i"));
        }
        
        if (amenities != null && !amenities.isEmpty()) {
            query.addCriteria(Criteria.where("amenities").all(amenities));
        }
        
        if (minPrice != null || maxPrice != null) {
            Criteria priceCriteria = Criteria.where("pricePerNightAdults");
            if (minPrice != null) priceCriteria.gte(minPrice);
            if (maxPrice != null) priceCriteria.lte(maxPrice);
            
            query.addCriteria(
                Criteria.where("rooms").elemMatch(priceCriteria)
            );
        }
        
        List<Property> properties = mongoTemplate.find(query, Property.class);
        return properties.stream()
            .map(this::mapToDTO)
            .collect(Collectors.toList());
    }
}
\end{minted}

\subsubsection{Geospatial Queries}

MongoDB's geospatial capabilities enable proximity-based searches:

\begin{minted}[fontsize=\small]{java}
public List<PropertyResponseDTO> getPropertiesInArea(double lat, 
                                                      double lon, 
                                                      double radiusKm) {
    Query query = new Query();
    query.addCriteria(
        Criteria.where("location")
            .nearSphere(new Point(lon, lat))
            .maxDistance(radiusKm / 6378.1)  // Earth radius in km
    );
    
    List<Property> properties = mongoTemplate.find(query, Property.class);
    return properties.stream()
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}
\end{minted}

\subsubsection{Trending Properties with Redis}

Redis sorted sets track property view counts for trending rankings:

\begin{minted}[fontsize=\small]{java}
public PropertyResponseDTO getPropertyDetails(String propertyId) {
    Property property = propertyRepository.findById(propertyId)
        .orElseThrow(() -> new IllegalArgumentException("Property not found"));
    
    // Increment view counter in Redis
    try {
        redisTemplate.opsForZSet()
            .incrementScore("trending_properties", propertyId, 1);
    } catch (Exception e) {
        System.err.println("Redis error: " + e.getMessage());
    }
    
    return mapToDTO(property);
}

public List<PropertyResponseDTO> getTrendingProperties() {
    try {
        var topIds = redisTemplate.opsForZSet()
            .reverseRange("trending_properties", 0, 9);
        
        if (topIds == null || topIds.isEmpty()) {
            return List.of();
        }
        
        List<String> ids = topIds.stream()
            .map(Object::toString)
            .collect(Collectors.toList());
        
        List<Property> properties = (List<Property>) 
            propertyRepository.findAllById(ids);
        
        return properties.stream()
            .map(this::mapToDTO)
            .collect(Collectors.toList());
    } catch (Exception e) {
        return List.of();
    }
}
\end{minted}

\subsection{RecommendationService}

Combines collaborative filtering (Neo4j) and content-based filtering (MongoDB) for personalized recommendations:

\subsubsection{Collaborative Filtering}

Uses graph traversals to find properties booked by similar users:

\begin{minted}[fontsize=\small]{java}
@Service
@RequiredArgsConstructor
public class RecommendationService {
    private final Neo4jClient neo4jClient;
    private final PropertyRepository propertyRepository;
    private final MongoTemplate mongoTemplate;
    
    public List<PropertyResponseDTO> getCollaborativeRecommendations(
            String propertyId) {
        
        String cypherQuery = """
            MATCH (p:Property {propertyId: $propId})<-[:BOOKED]-(u:User)
                  -[:BOOKED]->(other:Property)
            RETURN other.propertyId AS recommendedId, count(*) AS strength
            ORDER BY strength DESC
            LIMIT 5
        """;
        
        Collection<String> recommendedIds = neo4jClient.query(cypherQuery)
            .bind(propertyId).to("propId")
            .fetchAs(String.class)
            .mappedBy((typeSystem, record) -> 
                record.get("recommendedId").asString())
            .all();
        
        if (recommendedIds.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<Property> properties = (List<Property>) 
            propertyRepository.findAllById(recommendedIds);
        
        return properties.stream()
            .map(this::mapToDTO)
            .collect(Collectors.toList());
    }
}
\end{minted}

The Cypher query performs the following steps:
\begin{enumerate}
    \item Find all users who booked the given property
    \item Find all other properties booked by those users
    \item Count how many times each property appears
    \item Return the top 5 most frequently co-booked properties
\end{enumerate}

\subsubsection{Content-Based Filtering}

Recommends properties with similar amenities:

\begin{minted}[fontsize=\small]{java}
public List<PropertyResponseDTO> getContentBasedRecommendations(
        String propertyId) {
    
    Property current = propertyRepository.findById(propertyId)
        .orElse(null);
    
    if (current == null || current.getAmenities() == null || 
        current.getAmenities().isEmpty()) {
        return Collections.emptyList();
    }
    
    Query query = new Query();
    query.addCriteria(Criteria.where("_id").ne(propertyId));
    query.addCriteria(Criteria.where("amenities").in(current.getAmenities()));
    query.limit(10);
    
    List<Property> candidates = mongoTemplate.find(query, Property.class);
    
    // Sort by number of common amenities
    candidates.sort((p1, p2) -> {
        long common1 = countCommon(p1.getAmenities(), current.getAmenities());
        long common2 = countCommon(p2.getAmenities(), current.getAmenities());
        return Long.compare(common2, common1);
    });
    
    return candidates.stream()
        .limit(5)
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}

private long countCommon(List<String> l1, List<String> l2) {
    if (l1 == null || l2 == null) return 0;
    List<String> copy = new ArrayList<>(l1);
    copy.retainAll(l2);
    return copy.size();
}
\end{minted}

\subsection{AnalyticsService}

Provides business intelligence for property managers:

\begin{minted}[fontsize=\small]{java}
@Service
@RequiredArgsConstructor
public class AnalyticsService {
    private final PropertyRepository propertyRepository;
    private final ReservationRepository reservationRepository;
    private final JwtUtil jwtUtil;
    
    public AnalyticsResponseDTO getPropertyAnalytics(String token, 
                                                      String propertyId,
                                                      LocalDate startDate,
                                                      LocalDate endDate) {
        RegisteredUser manager = getManagerFromToken(token);
        
        Property property = propertyRepository.findById(propertyId)
            .orElseThrow(() -> 
                new IllegalArgumentException("Property not found"));
        
        if (!property.getManagerId().equals(manager.getId())) {
            throw new SecurityException(
                "You can only view analytics of your own properties");
        }
        
        return calculateAnalytics(property, startDate, endDate);
    }
    
    private AnalyticsResponseDTO calculateAnalytics(Property property,
                                                     LocalDate start,
                                                     LocalDate end) {
        List<String> roomIds = property.getRooms().stream()
            .map(Room::getId)
            .collect(Collectors.toList());
        
        List<Reservation> reservations = 
            reservationRepository.findByRoomIdIn(roomIds);
        
        if (start != null && end != null) {
            reservations = reservations.stream()
                .filter(r -> !r.getDates().getCheckIn().isBefore(start) &&
                           !r.getDates().getCheckOut().isAfter(end.plusDays(1)))
                .collect(Collectors.toList());
        }
        
        long totalReservations = reservations.size();
        double totalRevenue = reservations.stream()
            .mapToDouble(this::calculateReservationRevenue)
            .sum();
        
        double occupancyRate = calculateOccupancyRate(
            property.getRooms(), reservations, start, end);
        
        return AnalyticsResponseDTO.builder()
            .propertyName(property.getName())
            .totalReservations((int) totalReservations)
            .totalRevenue(totalRevenue)
            .occupancyRate(occupancyRate)
            .periodStart(start)
            .periodEnd(end)
            .build();
    }
}
\end{minted}

\subsection{ReservationService}

Manages the complete booking lifecycle with availability checking and payment processing:

\begin{minted}[fontsize=\small]{java}
@Service
@RequiredArgsConstructor
public class ReservationService {
    private final ReservationRepository reservationRepository;
    private final PropertyRepository propertyRepository;
    private final UserRepository userRepository;
    
    public ReservationResponseDTO createReservation(String token,
                                                     ReservationRequestDTO request) {
        // 1. Validate user
        RegisteredUser user = getUserFromToken(token);
        
        // 2. Find property and room
        Property property = propertyRepository.findById(request.getPropertyId())
            .orElseThrow(() -> 
                new IllegalArgumentException("Property not found"));
        
        Room room = property.getRooms().stream()
            .filter(r -> r.getId().equals(request.getRoomId()))
            .findFirst()
            .orElseThrow(() -> 
                new IllegalArgumentException("Room not found"));
        
        // 3. Check availability
        List<Reservation> conflicts = reservationRepository
            .findConflictingReservations(
                request.getRoomId(),
                request.getCheckIn(),
                request.getCheckOut()
            );
        
        if (!conflicts.isEmpty()) {
            throw new IllegalStateException(
                "Room not available for selected dates");
        }
        
        // 4. Calculate price
        long nights = ChronoUnit.DAYS.between(
            request.getCheckIn(), request.getCheckOut());
        
        double totalPrice = (room.getPricePerNightAdults() * request.getAdults() +
                           room.getPricePerNightChildren() * request.getChildren()) 
                           * nights;
        
        // 5. Process payment
        Customer customer = (Customer) user;
        boolean paymentSuccess = processPayment(
            customer.getPaymentMethod(), totalPrice);
        
        if (!paymentSuccess) {
            throw new IllegalStateException("Payment failed");
        }
        
        // 6. Create reservation
        Reservation reservation = Reservation.builder()
            .userId(user.getId())
            .roomId(request.getRoomId())
            .adults(request.getAdults())
            .children(request.getChildren())
            .dates(Reservation.ReservationDates.builder()
                .checkIn(request.getCheckIn())
                .checkOut(request.getCheckOut())
                .build())
            .status("CONFIRMED")
            .build();
        
        Reservation saved = reservationRepository.save(reservation);
        
        return mapToResponseDTO(saved, property, room, totalPrice);
    }
}
\end{minted}

\section{Controller Layer}

Controllers expose RESTful API endpoints and handle HTTP request/response mapping.

\subsection{PropertyController}

\begin{minted}[fontsize=\small]{java}
@RestController
@RequestMapping("/api/properties")
@RequiredArgsConstructor
public class PropertyController {
    private final PropertyService propertyService;
    
    @GetMapping("/search")
    public ResponseEntity<List<PropertyResponseDTO>> searchProperties(
            @RequestParam(required = false) String city,
            @RequestParam(required = false) Double minPrice,
            @RequestParam(required = false) Double maxPrice,
            @RequestParam(required = false) List<String> amenities) {
        
        List<PropertyResponseDTO> results = propertyService.searchProperties(
            city, minPrice, maxPrice, amenities);
        
        return ResponseEntity.ok(results);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<PropertyResponseDTO> getPropertyDetails(
            @PathVariable String id) {
        
        PropertyResponseDTO property = propertyService.getPropertyDetails(id);
        return ResponseEntity.ok(property);
    }
    
    @GetMapping("/trending")
    public ResponseEntity<List<PropertyResponseDTO>> getTrending() {
        List<PropertyResponseDTO> trending = 
            propertyService.getTrendingProperties();
        return ResponseEntity.ok(trending);
    }
    
    @GetMapping("/near")
    public ResponseEntity<List<PropertyResponseDTO>> getPropertiesNearby(
            @RequestParam double lat,
            @RequestParam double lon,
            @RequestParam(defaultValue = "10") double radiusKm) {
        
        List<PropertyResponseDTO> nearby = 
            propertyService.getPropertiesInArea(lat, lon, radiusKm);
        
        return ResponseEntity.ok(nearby);
    }
}
\end{minted}

\subsection{ManagerController}

Protected endpoints for property management:

\begin{minted}[fontsize=\small]{java}
@RestController
@RequestMapping("/api/manager")
@RequiredArgsConstructor
public class ManagerController {
    private final ManagerPropertyService managerPropertyService;
    private final AnalyticsService analyticsService;
    
    @GetMapping("/properties")
    public ResponseEntity<List<PropertyResponseDTO>> getMyProperties(
            @RequestHeader("Authorization") String token) {
        
        List<PropertyResponseDTO> properties = 
            managerPropertyService.getPropertiesByManager(token);
        
        return ResponseEntity.ok(properties);
    }
    
    @PostMapping("/properties")
    public ResponseEntity<PropertyResponseDTO> addProperty(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody PropertyRequestDTO request) {
        
        PropertyResponseDTO created = 
            managerPropertyService.addProperty(token, request);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @GetMapping("/analytics/property/{propertyId}")
    public ResponseEntity<AnalyticsResponseDTO> getPropertyAnalytics(
            @RequestHeader("Authorization") String token,
            @PathVariable String propertyId,
            @RequestParam(required = false) 
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam(required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        AnalyticsResponseDTO analytics = analyticsService.getPropertyAnalytics(
            token, propertyId, startDate, endDate);
        
        return ResponseEntity.ok(analytics);
    }
}
\end{minted}

\subsection{LoginController}

\begin{minted}[fontsize=\small]{java}
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class LoginController {
    private final LoginService loginService;
    
    @PostMapping("/login")
    public ResponseEntity<LoginResponseDTO> login(
            @Valid @RequestBody LoginRequestDTO request) {
        
        LoginResponseDTO response = loginService.login(request);
        return ResponseEntity.ok(response);
    }
}
\end{minted}

\section{Security Configuration}

\subsection{JWT Authentication}

The application uses JWT (JSON Web Tokens) for stateless authentication:

\begin{minted}[fontsize=\small]{java}
@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    public String generateToken(String email, String role) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);
        
        return Jwts.builder()
            .setSubject(email)
            .claim("role", role)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public Claims extractClaims(String token) {
        return Jwts.parser()
            .setSigningKey(secret)
            .parseClaimsJws(token)
            .getBody();
    }
    
    public boolean isTokenValid(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
\end{minted}

\subsection{JWT Authentication Filter}

Intercepts requests to validate JWT tokens:

\begin{minted}[fontsize=\small]{java}
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) 
            throws ServletException, IOException {
        
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            
            if (jwtUtil.isTokenValid(token)) {
                Claims claims = jwtUtil.extractClaims(token);
                String email = claims.getSubject();
                String role = claims.get("role", String.class);
                
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(
                        email, null, 
                        List.of(new SimpleGrantedAuthority("ROLE_" + role))
                    );
                
                SecurityContextHolder.getContext()
                    .setAuthentication(authentication);
            }
        }
        
        filterChain.doFilter(request, response);
    }
}
\end{minted}

\subsection{Security Configuration}

\begin{minted}[fontsize=\small]{java}
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthFilter;
    
    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter) {
        this.jwtAuthFilter = jwtAuthFilter;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) 
            throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**", 
                                "/v3/api-docs/**", 
                                "/swagger-ui/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/properties/**").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement(sess -> sess
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .addFilterBefore(jwtAuthFilter, 
                           UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
\end{minted}

Key security features:
\begin{itemize}
    \item \textbf{Stateless authentication}: No server-side sessions
    \item \textbf{BCrypt password hashing}: Industry-standard password security
    \item \textbf{Role-based access control}: Different permissions for CUSTOMER and MANAGER roles
    \item \textbf{Public endpoints}: Property browsing available without authentication
    \item \textbf{Protected endpoints}: Bookings and management require valid JWT
\end{itemize}

\section{Exception Handling}

Centralized exception handling using \texttt{@ControllerAdvice}:

\begin{minted}[fontsize=\small]{java}
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(
            IllegalArgumentException ex) {
        
        ErrorResponse error = ErrorResponse.builder()
            .message(ex.getMessage())
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .build();
        
        return ResponseEntity.badRequest().body(error);
    }
    
    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<ErrorResponse> handleSecurityException(
            SecurityException ex) {
        
        ErrorResponse error = ErrorResponse.builder()
            .message(ex.getMessage())
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.FORBIDDEN.value())
            .build();
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex) {
        
        ErrorResponse error = ErrorResponse.builder()
            .message("Internal server error")
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(error);
    }
}
\end{minted}

\section{API Documentation}

The application uses SpringDoc OpenAPI for automatic API documentation generation, accessible at \texttt{http://localhost:8080/swagger-ui.html}.

Configuration in \texttt{pom.xml}:

\begin{minted}[fontsize=\small]{xml}
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.3.0</version>
</dependency>
\end{minted}

API documentation includes:
\begin{itemize}
    \item Interactive endpoint testing
    \item Request/response schemas
    \item Authentication requirements
    \item Example payloads
\end{itemize}

\section{Data Population Scripts}

The project includes Python scripts for generating and populating realistic datasets.

\subsection{Dataset Generation}

The \texttt{createDataset.py} script generates synthetic data using the Faker library and real Airbnb data from InsideAirbnb:

\begin{minted}[fontsize=\small]{python}
import json
from faker import Faker
import requests

fake = Faker()
Faker.seed(42)

def generate_customer(available_property_ids=[]):
    first_name = fake.first_name()
    last_name = fake.last_name()
    
    favored_ids = []
    if available_property_ids:
        k = random.randint(0, min(3, len(available_property_ids)))
        favored_ids = random.sample(available_property_ids, k)
    
    return {
        "id": fake.uuid4(),
        "username": fake.user_name(),
        "email": fake.email(),
        "password": fake.password(),
        "name": first_name,
        "surname": last_name,
        "birthdate": fake.date_of_birth(minimum_age=18, maximum_age=90)
                         .isoformat(),
        "phoneNumber": fake.phone_number(),
        "paymentMethod": {
            "id": fake.uuid4(),
            "gatewayToken": fake.sha256(),
            "cardType": random.choice(["VISA", "MASTERCARD", "PAYPAL"]),
            "last4Digits": str(fake.random_number(digits=4, fix_len=True)),
            "expiryDate": fake.credit_card_expire(start="now", end="+5y"),
            "cardHolderName": f"{first_name} {last_name}".upper()
        },
        "favoredPropertyIds": favored_ids
    }
\end{minted}

\subsection{MongoDB Population}

The \texttt{populateMongoDB.py} script imports JSON data into MongoDB:

\begin{minted}[fontsize=\small]{python}
import pymongo
from datetime import datetime

client = pymongo.MongoClient("mongodb://localhost:27017/")
db = client["large_bnb_db"]

# Process and insert users
users_collection = []
for customer in raw_customers:
    customer['_id'] = customer.pop('id')
    customer['role'] = 'CUSTOMER'
    customer['birthdate'] = datetime.fromisoformat(customer['birthdate'])
    users_collection.append(customer)

db.users.delete_many({})
db.users.insert_many(users_collection)

# Process properties with embedded rooms
properties_final = []
for prop in raw_properties:
    prop['_id'] = prop.pop('id')
    
    # Convert coordinates [lat, lon] to GeoJSON [lon, lat]
    if 'coordinates' in prop:
        lat, lon = prop['coordinates']
        prop['location'] = {
            "type": "Point",
            "coordinates": [lon, lat]
        }
        del prop['coordinates']
    
    # Embed rooms
    prop['rooms'] = rooms_by_property.get(prop['_id'], [])
    properties_final.append(prop)

db.properties.delete_many({})
db.properties.insert_many(properties_final)
db.properties.create_index([("location", "2dsphere")])
\end{minted}

\subsection{Neo4j Population}

The \texttt{populateNeo4j.py} script creates graph nodes and relationships:

\begin{minted}[fontsize=\small]{python}
from neo4j import GraphDatabase

class LargeBnBImporter:
    def __init__(self, uri, auth):
        self.driver = GraphDatabase.driver(uri, auth=auth)
    
    def create_constraints(self):
        with self.driver.session() as session:
            session.run("""
                CREATE CONSTRAINT user_id IF NOT EXISTS 
                FOR (u:User) REQUIRE u.userId IS UNIQUE
            """)
            session.run("""
                CREATE CONSTRAINT property_id IF NOT EXISTS 
                FOR (p:Property) REQUIRE p.propertyId IS UNIQUE
            """)
    
    def import_users(self, customers, managers):
        query = """
        UNWIND $batch AS row
        MERGE (u:User {userId: row.id})
        SET u.name = row.name, u.role = row.role
        """
        
        all_users = []
        for c in customers:
            all_users.append({
                "id": c['id'], 
                "name": c.get('name', 'Unknown'), 
                "role": "CUSTOMER"
            })
        
        batch_size = 1000
        with self.driver.session() as session:
            for i in range(0, len(all_users), batch_size):
                batch = all_users[i:i+batch_size]
                session.run(query, batch=batch)
    
    def import_reservations(self, reservations, rooms):
        # Map room IDs to property IDs
        room_to_prop = {r['id']: r['property_id'] for r in rooms}
        
        query = """
        UNWIND $batch AS row
        MATCH (u:User {userId: row.userId})
        MATCH (p:Property {propertyId: row.propertyId})
        MERGE (u)-[:BOOKED {date: date(row.date)}]->(p)
        """
        
        rels = []
        for res in reservations:
            room_id = res.get('room_id')
            user_id = res.get('customer_id')
            property_id = room_to_prop.get(room_id)
            
            if property_id and user_id:
                rels.append({
                    "userId": user_id,
                    "propertyId": property_id,
                    "date": res.get('checkInDate', '2024-01-01')[:10]
                })
        
        with self.driver.session() as session:
            for i in range(0, len(rels), 1000):
                batch = rels[i:i+1000]
                session.run(query, batch=batch)
\end{minted}

This polyglot approach ensures optimal data distribution:
\begin{itemize}
    \item \textbf{MongoDB}: Operational data with complex structures and geospatial queries
    \item \textbf{Neo4j}: Relationship-based queries for recommendations
    \item \textbf{Redis}: High-speed caching for trending data
\end{itemize}
