\chapter{Most Relevant Queries}

This chapter presents the most relevant queries implemented in the application, showcasing how each database technology is leveraged to fulfill specific functional requirements. The queries are organized by database system and demonstrate the query-driven design approach adopted throughout the project.

\section{MongoDB Queries}

MongoDB serves as the primary database for the application, handling the majority of data storage and retrieval operations. The queries are implemented using Spring Data MongoDB's \texttt{@Query} and \texttt{@Aggregation} annotations directly in repository interfaces, providing a clean declarative approach.

\subsection{Property Search and Filtering}

The property search functionality is one of the most critical features of the platform, allowing users to find accommodations based on multiple criteria.

\subsubsection{Search by Name with Average Rating Calculation}

The following query demonstrates searching properties by name while calculating their average rating on-the-fly using an aggregation pipeline:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'name': { $regex: ?0, $options: 'i' } } }",
    "{ '$addFields': { 'averageRating': { '$cond': { 'if': { '$eq': ['$ratingStats.count', 0] }, 'then': 0, 'else': { '$divide': ['$ratingStats.sum', '$ratingStats.count'] } } } } }",
    "{ '$project': { 'id': '$_id', 'name': 1, 'city': 1, 'averageRating': 1 } }"
})
Slice<PropertySearchDTO> findByNameContaining(String name, Pageable pageable);
\end{lstlisting}

Key aspects of this aggregation:
\begin{itemize}
    \item \textbf{\$match stage}: Filters properties using case-insensitive regex (\texttt{\$options: 'i'}).
    \item \textbf{\$addFields stage}: Computes derived fields, using \texttt{\$cond} to handle division by zero.
    \item \textbf{\$project stage}: Shapes the output to only include relevant fields.
    \item \textbf{Pageable support}: Spring Data handles pagination automatically with \texttt{Slice<>}.
\end{itemize}

\subsubsection{Find Property by Room ID}

A query to find the parent property when only the room ID is known:

\begin{lstlisting}[style=javaStyle]
@Query("{ 'rooms.roomId': ?0 }")
Optional<Property> findByRoomsId(String roomId);
\end{lstlisting}

This leverages MongoDB's ability to query nested array elements using dot notation.

\subsubsection{Advanced Property Search with Multiple Filters}

The advanced search functionality allows optional filtering by city, amenities, and price range:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { $and: [ " +
    "   { $expr: { $or: [ { $eq: [?0, null] }, { $regexMatch: { input: '$city', regex: ?0, options: 'i' } } ] } }, " +
    "   { $expr: { $or: [ { $eq: [?3, null] }, { $eq: [?3, []] }, { $setIsSubset: [?3, '$amenities'] } ] } }, " +
    "   { $expr: { $or: [ " +
    "     { $and: [ { $eq: [?1, null] }, { $eq: [?2, null] } ] }, " +
    "     { $gt: [{ $size: { $filter: { input: '$rooms', as: 'room', cond: { $and: [ " +
    "       { $or: [ { $eq: [?1, null] }, { $gte: ['$$room.pricePerNightAdults', ?1] } ] }, " +
    "       { $or: [ { $eq: [?2, null] }, { $lte: ['$$room.pricePerNightAdults', ?2] } ] } " +
    "     ] } } } }, 0] } " +
    "   ] } } " +
    "] } }"
})
List<Property> searchPropertiesAdvanced(String city, Double minPrice, Double maxPrice, List<String> amenities);
\end{lstlisting}

This complex aggregation demonstrates:
\begin{itemize}
    \item \textbf{\$expr with \$or}: Handles null parameters gracefully for optional filters.
    \item \textbf{\$regexMatch}: Case-insensitive city search.
    \item \textbf{\$setIsSubset}: Verifies all requested amenities are present.
    \item \textbf{\$filter on embedded arrays}: Filters rooms by price range without \$unwind.
\end{itemize}

\subsubsection{Geospatial Query - Properties Near Location}

Finding properties within a specific radius using MongoDB's geospatial capabilities:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$geoNear': { " +
    "   'near': { 'type': 'Point', 'coordinates': [?1, ?0] }, " +
    "   'distanceField': 'distance', " +
    "   'maxDistance': ?2, " +
    "   'spherical': true " +
    "} }"
})
List<Property> findPropertiesNearLocation(double latitude, double longitude, double maxDistanceMeters);
\end{lstlisting}

Key aspects:
\begin{itemize}
    \item \textbf{\$geoNear}: Must be the first stage in the pipeline.
    \item \textbf{spherical: true}: Uses Earth's curvature for accurate distance calculation.
    \item \textbf{distanceField}: Automatically adds calculated distance to results.
    \item Requires a \texttt{2dsphere} index on the \texttt{coordinates} field.
\end{itemize}

\subsubsection{Top Rated Properties}

Retrieving properties sorted by average rating:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$addFields': { 'averageRating': { '$cond': { 'if': { '$eq': ['$ratingStats.count', 0] }, 'then': 0, 'else': { '$divide': ['$ratingStats.sum', '$ratingStats.count'] } } } } }",
    "{ '$sort': { 'averageRating': -1 } }",
    "{ '$limit': ?0 }"
})
List<Property> findTopRated(int limit);
\end{lstlisting}

This query:
\begin{itemize}
    \item Dynamically calculates average rating from stored sum and count.
    \item Handles division by zero using \texttt{\$cond}.
    \item Allows flexible limit parameter for different use cases.
\end{itemize}

\subsection{Reservation Management Queries}

\subsubsection{Availability Checking (Overlap Detection)}

One of the most critical queries ensures that double-booking is prevented:

\begin{lstlisting}[style=javaStyle]
@Query("{ 'roomId': ?0, 'status': { $ne: 'cancelled' }, 'dates.checkIn': { $lt: ?2 }, 'dates.checkOut': { $gt: ?1 } }")
List<Reservation> findOverlappingReservations(
    String roomId, LocalDate newCheckIn, LocalDate newCheckOut);
\end{lstlisting}

This query implements the classic interval overlap detection algorithm:
\begin{itemize}
    \item Two intervals [A, B] and [C, D] overlap if and only if A < D AND C < B.
    \item The \texttt{\$ne: 'cancelled'} filter excludes cancelled reservations.
    \item Proper indexing on \texttt{(roomId, dates.checkIn)} ensures O(log n) execution.
\end{itemize}

\subsubsection{Active Bookings Detection}

To prevent account deletion while active bookings exist:

\begin{lstlisting}[style=javaStyle]
@Query(value = "{ 'userId': ?0, 'status': 'confirmed', 'dates.checkOut': { $gt: ?1 } }", exists = true)
boolean hasActiveBookings(String userId, LocalDate today);
\end{lstlisting}

The \texttt{exists = true} parameter makes this an existence check query, returning a boolean instead of retrieving documents.

\subsection{Analytics Aggregation Pipelines}

The manager analytics dashboard leverages complex aggregation pipelines for business intelligence.

\subsubsection{Reservation Statistics by Status}

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'roomId': { $in: ?0 }, 'dates.checkIn': { $gte: ?1, $lte: ?2 } } }",
    "{ '$group': { '_id': null, 'totalReservations': { $sum: 1 }, 'confirmed': { $sum: { $cond: [{ $eq: ['$status', 'CONFIRMED'] }, 1, 0] } }, 'cancelled': { $sum: { $cond: [{ $eq: ['$status', 'CANCELLED'] }, 1, 0] } }, 'completed': { $sum: { $cond: [{ $eq: ['$status', 'COMPLETED'] }, 1, 0] } }, 'totalAdults': { $sum: '$adults' }, 'totalChildren': { $sum: '$children' } } }",
    "{ '$project': { '_id': 0 } }"
})
Map<String, Object> getReservationStatistics(
    List<String> roomIds, LocalDate startDate, LocalDate endDate);
\end{lstlisting}

This aggregation demonstrates:
\begin{itemize}
    \item \textbf{\$match with \$in}: Filters reservations for multiple rooms efficiently.
    \item \textbf{\$group with \$cond}: Conditional counting for status-based metrics.
    \item \textbf{Date range filtering}: Uses \texttt{\$gte} and \texttt{\$lte} for inclusive date bounds.
\end{itemize}

\subsubsection{Rating Evolution Over Time}

Analyzing how property ratings change over time:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'propertyId': ?0, 'creationDate': { $gte: ?1, $lte: ?2 } } }",
    "{ '$addFields': { 'yearMonth': { $dateToString: { format: '%Y-%m', date: '$creationDate' } } } }",
    "{ '$group': { '_id': '$yearMonth', 'averageRating': { $avg: '$rating' }, 'reviewCount': { $sum: 1 } } }",
    "{ '$sort': { '_id': 1 } }",
    "{ '$project': { 'month': '$_id', 'averageRating': 1, 'reviewCount': 1, '_id': 0 } }"
})
List<Map<String, Object>> getMonthlyRatingEvolution(
    String propertyId, LocalDate startDate, LocalDate endDate);
\end{lstlisting}

Key techniques:
\begin{itemize}
    \item \textbf{\$dateToString}: Formats dates for grouping by month.
    \item \textbf{\$avg}: Computes average rating per time period.
    \item Chronological sorting enables trend visualization.
\end{itemize}

\subsubsection{Trending Properties (Improving Ratings)}

Finding properties with improving ratings (recent reviews > historical average):

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$addFields': { " +
    "   'averageScore': { '$cond': { " +
    "       if: { '$gt': ['$ratingStats.count', 0] }, " +
    "       then: { '$divide': ['$ratingStats.sum', '$ratingStats.count'] }, " +
    "       else: 0 " +
    "   } }, " +
    "   'recentReviews': { '$slice': [ " +
    "       { '$sortArray': { 'input': '$reviews', 'sortBy': { 'timestamp': -1 } } }, " +
    "       5 ] } " +
    "} }",
    "{ '$addFields': { 'recentAverage': { '$avg': '$recentReviews.score' } } }",
    "{ '$match': { '$expr': { '$gt': ['$recentAverage', '$averageScore'] } } }",
    "{ '$addFields': { 'scoreDifference': { '$subtract': ['$recentAverage', '$averageScore'] } } }",
    "{ '$sort': { 'scoreDifference': -1 } }",
    "{ '$limit': 10 }",
    "{ '$project': { '_id': 0, 'id': '$_id', 'name': 1, 'scoreDifference': 1 } }"
})
List<TrendingPropertyDTO> findTopImprovingProperties();
\end{lstlisting}

Advanced techniques demonstrated:
\begin{itemize}
    \item \textbf{\$sortArray}: Sorts embedded array by timestamp without \$unwind.
    \item \textbf{\$slice}: Takes only the 5 most recent reviews.
    \item \textbf{\$expr in \$match}: Enables comparison between computed fields.
    \item \textbf{Multi-stage \$addFields}: Builds up computed values incrementally.
\end{itemize}

\subsubsection{Top Properties by Genre/Category (Optional Filter)}

Finding top-rated properties with optional category filtering:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { '$expr': { '$or': [ { '$eq': [?0, null] }, { '$in': [?0, '$amenities'] } ] } } }",
    "{ '$addFields': { 'averageScore': { '$cond': { 'if': { '$gt': ['$ratingStats.count', 0] }, 'then': { '$divide': ['$ratingStats.sum', '$ratingStats.count'] }, 'else': 0 } } } }",
    "{ '$sort': { 'averageScore': -1 } }",
    "{ '$limit': 10 }",
    "{ '$project': { 'id': 1, 'name': 1, 'averageScore': 1 } }"
})
List<PropertyAverageDTO> findTop10Properties(String amenity);
\end{lstlisting}

This query handles optional parameters elegantly using \texttt{\$expr} with \texttt{\$or}.

\subsection{Update Operations with @Query and @Update}

Spring Data MongoDB supports atomic update operations using the combination of \texttt{@Query} and \texttt{@Update} annotations.

\subsubsection{Update Username in Reviews}

When a user changes their username, all their reviews must be updated:

\begin{lstlisting}[style=javaStyle]
@Query("{ 'reviews.username': ?0 }")
@Update("{ '$set': { 'reviews.$.username': ?1 } }")
void updateReviewsByUsername(String oldUsername, String newUsername);
\end{lstlisting}

The positional operator \texttt{\$} identifies the matched array element for the update.

\subsubsection{Remove User Reviews on Account Deletion}

\begin{lstlisting}[style=javaStyle]
@Query("{ 'reviews.username': ?0 }")
@Update("{ '$pull': { 'reviews': { 'username': ?0 } } }")
void deleteReviewsByUsername(String username);
\end{lstlisting}

The \texttt{\$pull} operator removes all matching elements from the embedded array in a single atomic operation.

\subsubsection{Increment Rating Statistics}

\begin{lstlisting}[style=javaStyle]
@Query("{ '_id': ?0 }")
@Update("{ '$inc': { 'ratingStats.count': 1, 'ratingStats.sum': ?1 } }")
void incrementRatingStats(String propertyId, int rating);
\end{lstlisting}

The \texttt{\$inc} operator provides atomic increment operations, essential for concurrent rating submissions.

\subsection{Most Controversial Properties}

Finding properties with highest rating variance (most polarizing opinions):

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$addFields': { 'variance': { '$pow': [{ '$stdDevPop': '$reviews.rating' }, 2] } } }",
    "{ '$match': { 'variance': { $gt: 0 } } }",
    "{ '$sort': { 'variance': -1 } }",
    "{ '$limit': 10 }",
    "{ '$project': { '_id': 0, 'id': '$_id', 'name': 1, 'variance': 1 } }"
})
List<ControversialPropertyDTO> findMostControversialProperties();
\end{lstlisting}

This uses MongoDB's \texttt{\$stdDevPop} (population standard deviation) function to measure rating dispersion.

\subsection{Message Conversation Retrieval}

The messaging system requires bidirectional message retrieval:

\begin{lstlisting}[style=javaStyle]
@Query(value = "{ $or: [ { 'senderId': ?0, 'recipientId': ?1 }, { 'senderId': ?1, 'recipientId': ?0 } ] }", 
       sort = "{ 'timestamp': 1 }")
List<Message> findConversation(String user1, String user2);
\end{lstlisting}

This query:
\begin{itemize}
    \item Uses \texttt{\$or} to match messages in both directions.
    \item Sorts by timestamp ascending to display conversation chronologically.
    \item Leverages compound index on \texttt{(senderId, recipientId)} for performance.
\end{itemize}

\section{Neo4j Queries}

Neo4j powers the recommendation engine through graph-based queries using Cypher, Neo4j's declarative query language.

\subsection{Collaborative Filtering Recommendations}

The primary recommendation algorithm identifies properties booked by users with similar preferences:

\begin{lstlisting}[style=javaStyle]
public List<PropertyResponseDTO> getCollaborativeRecommendations(
        String propertyId) {
    
    String cypherQuery = """
        MATCH (p:Property {propertyId: $propId})<-[:BOOKED]-(u:User)
              -[:BOOKED]->(other:Property)
        RETURN other.propertyId AS recommendedId, 
               count(*) AS strength
        ORDER BY strength DESC
        LIMIT 5
    """;

    Collection<String> recommendedIds = neo4jClient.query(cypherQuery)
        .bind(propertyId).to("propId")
        .fetchAs(String.class)
        .mappedBy((typeSystem, record) -> 
            record.get("recommendedId").asString())
        .all();

    return propertyRepository.findAllById(recommendedIds);
}
\end{lstlisting}

The Cypher query pattern works as follows:
\begin{itemize}
    \item \textbf{Start node}: Finds the property being viewed.
    \item \textbf{First hop}: Traverses \texttt{BOOKED} relationships backward to find users who booked this property.
    \item \textbf{Second hop}: Traverses \texttt{BOOKED} relationships forward to find other properties these users booked.
    \item \textbf{Aggregation}: Groups by property and counts co-occurrences as "strength".
    \item \textbf{Ranking}: Orders by strength to surface the most relevant recommendations.
\end{itemize}

This implements the classic "users who booked X also booked Y" collaborative filtering pattern.

\subsection{Graph Constraints for Data Integrity}

The application creates constraints at startup to ensure graph integrity:

\begin{lstlisting}[style=javaStyle]
@EventListener(ApplicationReadyEvent.class)
public void createIndexesAndConstraints() {
    List<String> startupQueries = List.of(
        // Property uniqueness - O(1) lookup for recommendations
        "CREATE CONSTRAINT property_id_unique IF NOT EXISTS " +
        "FOR (p:Property) REQUIRE p.id IS UNIQUE",

        // User uniqueness - essential for collaborative filtering
        "CREATE CONSTRAINT user_id_unique IF NOT EXISTS " +
        "FOR (u:User) REQUIRE u.id IS UNIQUE",

        // Amenity uniqueness - ensures shared nodes for traversal
        "CREATE CONSTRAINT amenity_name_unique IF NOT EXISTS " +
        "FOR (a:Amenity) REQUIRE a.name IS UNIQUE"
    );

    startupQueries.forEach(query -> neo4jClient.query(query).run());
}
\end{lstlisting}

These constraints serve dual purposes:
\begin{itemize}
    \item \textbf{Data integrity}: Prevents duplicate nodes.
    \item \textbf{Performance}: Creates implicit indexes for O(1) lookups.
\end{itemize}

\section{Redis Queries and Operations}

Redis provides in-memory data structures for caching, session management, and real-time features.

\subsection{Token Blacklisting for Secure Logout}

JWT tokens are stateless by design, but the application implements secure logout through Redis blacklisting:

\begin{lstlisting}[style=javaStyle]
public void blacklistToken(String token) {
    String cleanedToken = cleanToken(token);
    Claims claims = getClaims(cleanedToken);
    
    // Calculate remaining TTL
    long tokenExpiration = claims.getExpiration().getTime();
    long currentTime = System.currentTimeMillis();
    long ttl = tokenExpiration - currentTime;

    if (ttl > 0) {
        // Key format: "blacklist:<token>"
        redisTemplate.opsForValue()
            .set("blacklist:" + cleanedToken, "true", 
                 ttl, TimeUnit.MILLISECONDS);
    }
}

private boolean isTokenBlacklisted(String token) {
    Boolean exists = redisTemplate.hasKey("blacklist:" + token);
    return exists != null && exists;
}
\end{lstlisting}

Key design decisions:
\begin{itemize}
    \item \textbf{TTL-based expiration}: Blacklist entries automatically expire when the token would have naturally expired, preventing unbounded memory growth.
    \item \textbf{String data type}: Simple key-value structure for O(1) lookup.
    \item \textbf{Validation integration}: Token validation checks blacklist before accepting requests.
\end{itemize}

\subsection{Pessimistic Locking for Reservations}

To prevent double-booking during the payment window, Redis implements temporary locks:

\begin{lstlisting}[style=javaStyle]
private static final String REDIS_PREFIX = "temp_res:";

public ReservationResponseDTO initiateReservation(
        String token, ReservationRequestDTO request) {
    
    // Check MongoDB for confirmed bookings
    List<Reservation> confirmedOverlaps = reservationRepository
        .findOverlappingReservations(room.getId(), 
            request.getCheckIn(), request.getCheckOut());
    
    if (!confirmedOverlaps.isEmpty()) {
        throw new IllegalStateException("Room already booked");
    }

    // Check Redis for temporary locks
    Set<String> keys = redisTemplate.keys(REDIS_PREFIX + "*");
    if (keys != null) {
        for (String key : keys) {
            Reservation pending = objectMapper.convertValue(
                redisTemplate.opsForValue().get(key), 
                Reservation.class);
            
            if (pending != null && 
                pending.getRoomId().equals(room.getId()) &&
                isOverlapping(pending.getDates(), 
                    request.getCheckIn(), request.getCheckOut())) {
                throw new IllegalStateException(
                    "Room being paid for. Try again in 15 mins.");
            }
        }
    }

    // Create temporary reservation with 15-minute TTL
    String tempId = UUID.randomUUID().toString();
    Reservation tempReservation = Reservation.builder()
        .id(tempId)
        .roomId(room.getId())
        .dates(new ReservationDates(
            request.getCheckIn(), request.getCheckOut()))
        .status("PENDING_PAYMENT")
        .build();

    redisTemplate.opsForValue()
        .set(REDIS_PREFIX + tempId, tempReservation, 
             15, TimeUnit.MINUTES);
    
    return mapToDTO(tempReservation);
}
\end{lstlisting}

This implements a pessimistic locking pattern:
\begin{itemize}
    \item \textbf{Temporary reservation}: Stored in Redis with 15-minute TTL during payment.
    \item \textbf{Overlap checking}: Both MongoDB (confirmed) and Redis (pending) are checked.
    \item \textbf{Automatic unlock}: TTL ensures locks are released if payment is abandoned.
\end{itemize}

\subsection{Trending Properties with Sorted Sets}

Redis sorted sets maintain real-time property popularity rankings:

\begin{lstlisting}[style=javaStyle]
// Increment view count when property is viewed
public PropertyResponseDTO getPropertyDetails(String propertyId) {
    Property property = propertyRepository.findById(propertyId)
        .orElseThrow(() -> new IllegalArgumentException("Not found"));

    // ZINCRBY trending_properties 1 <propertyId>
    redisTemplate.opsForZSet()
        .incrementScore("trending_properties", propertyId, 1);

    return mapToDTO(property);
}

// Get top 10 trending properties
public List<PropertyResponseDTO> getTrendingProperties() {
    // ZREVRANGE trending_properties 0 9
    var topIds = redisTemplate.opsForZSet()
        .reverseRange("trending_properties", 0, 9);
    
    if (topIds == null || topIds.isEmpty()) return List.of();

    List<String> ids = topIds.stream()
        .map(Object::toString)
        .collect(Collectors.toList());
    
    return propertyRepository.findAllById(ids).stream()
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}
\end{lstlisting}

Redis sorted sets provide:
\begin{itemize}
    \item \textbf{O(log N) insertion}: Efficient score updates.
    \item \textbf{O(log N + M) range queries}: Fast top-K retrieval.
    \item \textbf{Atomic operations}: Thread-safe score increments.
\end{itemize}

\subsection{User Browsing History with Lists}

Redis lists store recently viewed properties per user:

\begin{lstlisting}[style=javaStyle]
public void addToUserHistory(String userId, String propertyId) {
    String key = "history:" + userId;
    
    // LPUSH adds to front of list
    redisTemplate.opsForList().leftPush(key, propertyId);
    
    // LTRIM keeps only last 10 items
    redisTemplate.opsForList().trim(key, 0, 9);
}

public List<PropertyResponseDTO> getUserHistory(String userId) {
    String key = "history:" + userId;
    
    // LRANGE retrieves all items
    List<Object> historyIds = redisTemplate.opsForList()
        .range(key, 0, -1);
    
    if (historyIds == null || historyIds.isEmpty()) 
        return List.of();

    List<String> ids = historyIds.stream()
        .map(Object::toString)
        .collect(Collectors.toList());
    
    return propertyRepository.findAllById(ids).stream()
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}
\end{lstlisting}

This pattern:
\begin{itemize}
    \item Uses \texttt{LPUSH} for O(1) insertion at head.
    \item Uses \texttt{LTRIM} to maintain fixed-size history (last 10 properties).
    \item Provides O(1) retrieval for "recently viewed" feature.
\end{itemize}

\section{Summary}

The query implementations in this chapter demonstrate how the application leverages each database technology's strengths:

\begin{itemize}
    \item \textbf{MongoDB}: Complex document queries using \texttt{@Query} annotations, powerful aggregation pipelines with \texttt{@Aggregation} for analytics, and atomic updates with \texttt{@Update}.
    \item \textbf{Neo4j}: Graph traversal for collaborative filtering recommendations, relationship management with Cypher's \texttt{MERGE} and \texttt{MATCH} patterns.
    \item \textbf{Redis}: In-memory caching with TTL, pessimistic locking for reservations, real-time rankings with sorted sets, and browsing history with lists.
\end{itemize}

The query-driven design approach ensures that data models are optimized for the access patterns they need to support, resulting in efficient and maintainable database operations throughout the application.