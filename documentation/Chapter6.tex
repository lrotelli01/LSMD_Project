\chapter{Most Relevant Queries}

This chapter presents the most relevant queries implemented in the application, showcasing how each database technology is leveraged to fulfill specific functional requirements. The queries are organized by database system and demonstrate the query-driven design approach adopted throughout the project.

\section{MongoDB Queries}

MongoDB serves as the primary database for the application, handling the majority of data storage and retrieval operations. The queries are implemented using Spring Data MongoDB's \texttt{@Query} and \texttt{@Aggregation} annotations in repository interfaces, as well as \texttt{MongoTemplate} for dynamic query construction in service classes.

\subsection{Property Search and Filtering}

The property search functionality is one of the most critical features of the platform, allowing users to find accommodations based on multiple criteria.

\subsubsection{Advanced Property Search with MongoTemplate}

The advanced search functionality uses \texttt{MongoTemplate} for dynamic query construction, allowing optional filtering by city, amenities, and price range:

\begin{lstlisting}[style=javaStyle]
public List<PropertyResponseDTO> searchProperties(String city, Double minPrice, 
                                    Double maxPrice, List<String> amenities) {
    Query query = new Query();

    // City Filter (Case Insensitive: Rome == rome)
    if (city != null && !city.trim().isEmpty()) {
        query.addCriteria(Criteria.where("city").regex(city, "i"));
    }

    // Price Filter (Search in internal rooms)
    if (minPrice != null || maxPrice != null) {
        Criteria priceCriteria = Criteria.where("pricePerNightAdults");
        if (minPrice != null) priceCriteria.gte(minPrice);
        if (maxPrice != null) priceCriteria.lte(maxPrice);
        
        // elemMatch: Checks if AT LEAST ONE room satisfies the price range
        query.addCriteria(Criteria.where("rooms").elemMatch(priceCriteria));
    }

    // Amenities Filter (Uses Regex to handle data inconsistencies)
    if (amenities != null && !amenities.isEmpty()) {
        List<Criteria> amenityCriteria = new ArrayList<>();
        for (String amenity : amenities) {
            amenityCriteria.add(Criteria.where("amenities").regex(amenity, "i"));
        }
        // AND Operator: Property must have ALL requested amenities
        query.addCriteria(new Criteria()
            .andOperator(amenityCriteria.toArray(new Criteria[0])));
    }

    List<Property> properties = mongoTemplate.find(query, Property.class);
    return properties.stream().map(this::mapToDTO).collect(Collectors.toList());
}
\end{lstlisting}

Key aspects of this implementation:
\begin{itemize}
    \item \textbf{Dynamic query construction}: Criteria are added only when parameters are provided, enabling flexible optional filtering.
    \item \textbf{Case-insensitive regex}: The \texttt{"i"} flag enables case-insensitive matching for city and amenities.
    \item \textbf{\$elemMatch on embedded arrays}: Efficiently filters properties having at least one room within the price range.
    \item \textbf{AND operator}: Ensures all requested amenities are present using \texttt{andOperator()}.
\end{itemize}

\subsubsection{Geospatial Query - Properties Near Location}

Finding properties within a specific radius using MongoDB's geospatial capabilities:

\begin{lstlisting}[style=javaStyle]
public List<PropertyResponseDTO> getPropertiesInArea(double lat, double lon, 
                                                      double radiusKm) {
    // GeoJsonPoint(x=lon, y=lat) - GeoJSON uses [longitude, latitude]
    GeoJsonPoint point = new GeoJsonPoint(lon, lat);
    // Limit maximum radius to 100km to avoid heavy queries
    double maxRadiusKm = Math.min(radiusKm, 100.0);
    // For $nearSphere with GeoJSON and 2dsphere index, $maxDistance is in METERS
    double radiusMeters = maxRadiusKm * 1000;
    
    Query query = new Query();
    query.addCriteria(Criteria.where("location")
        .nearSphere(point).maxDistance(radiusMeters));
    query.limit(100); // Limit results for performance
    
    List<Property> properties = mongoTemplate.find(query, Property.class);
    return properties.stream().map(this::mapToDTO).collect(Collectors.toList());
}
\end{lstlisting}

Key aspects:
\begin{itemize}
    \item \textbf{GeoJSON format}: The \texttt{location} field stores coordinates as \texttt{\{ "type": "Point", "coordinates": [lon, lat] \}}.
    \item \textbf{nearSphere}: Uses spherical geometry for accurate distance calculation on Earth's surface.
    \item \textbf{Radius limiting}: Caps the search radius at 100km to prevent performance issues.
    \item Requires a \texttt{2dsphere} index on the \texttt{location} field.
\end{itemize}

\subsubsection{Room Search with Multiple Filters}

A comprehensive room search allowing filtering by type, price, capacity, and amenities:

\begin{lstlisting}[style=javaStyle]
public List<RoomResponseDTO> searchRooms(String city, String roomType, 
        Double minPrice, Double maxPrice, Integer minCapacity, 
        List<String> amenities) {
    Query query = new Query();

    // City Filter (Case Insensitive)
    if (city != null && !city.trim().isEmpty()) {
        query.addCriteria(Criteria.where("city").regex(city, "i"));
    }

    // Combine all room criteria in a single $elemMatch
    List<Criteria> roomCriteriaList = new ArrayList<>();
    
    // Room Type Filter
    if (roomType != null && !roomType.trim().isEmpty()) {
        roomCriteriaList.add(Criteria.where("roomType").regex(roomType, "i"));
    }

    // Price Filter
    if (minPrice != null) {
        roomCriteriaList.add(Criteria.where("pricePerNightAdults")
            .gte(minPrice.floatValue()));
    }
    if (maxPrice != null) {
        roomCriteriaList.add(Criteria.where("pricePerNightAdults")
            .lte(maxPrice.floatValue()));
    }

    // Minimum Capacity Filter
    if (minCapacity != null && minCapacity > 0) {
        roomCriteriaList.add(Criteria.where("capacityAdults")
            .gte(minCapacity.longValue()));
    }

    // Room Amenities Filter
    if (amenities != null && !amenities.isEmpty()) {
        for (String amenity : amenities) {
            roomCriteriaList.add(Criteria.where("amenities").regex(amenity, "i"));
        }
    }

    // Apply single combined $elemMatch
    if (!roomCriteriaList.isEmpty()) {
        Criteria combinedRoomCriteria = new Criteria().andOperator(
            roomCriteriaList.toArray(new Criteria[0])
        );
        query.addCriteria(Criteria.where("rooms").elemMatch(combinedRoomCriteria));
    }

    List<Property> properties = mongoTemplate.find(query, Property.class);
    // Post-processing to extract matching rooms...
}
\end{lstlisting}

This query demonstrates:
\begin{itemize}
    \item \textbf{Single \$elemMatch with AND}: All room-level filters are combined in one \texttt{elemMatch} with \texttt{andOperator}, ensuring the SAME room satisfies all criteria.
    \item \textbf{Post-query filtering}: After fetching properties, rooms are filtered in Java to return only those matching all criteria.
\end{itemize}

\subsection{Reservation Management Queries}

\subsubsection{Availability Checking (Overlap Detection)}

One of the most critical queries ensures that double-booking is prevented:

\begin{lstlisting}[style=javaStyle]
@Query("{ 'roomId': ?0, 'status': { $ne: 'cancelled' }, " +
       "'dates.checkIn': { $lt: ?2 }, 'dates.checkOut': { $gt: ?1 } }")
List<Reservation> findOverlappingReservations(
    String roomId, LocalDate newCheckIn, LocalDate newCheckOut);
\end{lstlisting}

This query implements the classic interval overlap detection algorithm:
\begin{itemize}
    \item Two intervals [A, B] and [C, D] overlap if and only if A < D AND C < B.
    \item The \texttt{\$ne: 'cancelled'} filter excludes cancelled reservations.
    \item Proper indexing on \texttt{(roomId, dates.checkIn)} ensures O(log n) execution.
\end{itemize}

\subsubsection{Active Bookings Detection}

To prevent account deletion while active bookings exist:

\begin{lstlisting}[style=javaStyle]
@Query(value = "{ 'userId': ?0, 'status': 'confirmed', " +
               "'dates.checkOut': { $gt: ?1 } }", exists = true)
boolean hasActiveBookings(String userId, LocalDate today);
\end{lstlisting}

The \texttt{exists = true} parameter makes this an existence check query, returning a boolean instead of retrieving documents.

\subsection{Analytics Aggregation Pipelines}

The manager analytics dashboard leverages complex aggregation pipelines for business intelligence. These are implemented in the \texttt{ReservationRepository} and \texttt{ReviewRepository}.

\subsubsection{Reservation Statistics by Status}

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'roomId': { $in: ?0 }, " +
    "   'dates.checkIn': { $gte: ?1, $lte: ?2 } } }",
    "{ '$group': { '_id': null, " +
    "   'totalReservations': { $sum: 1 }, " +
    "   'confirmed': { $sum: { $cond: [{ $eq: ['$status', 'CONFIRMED'] }, 1, 0] } }, " +
    "   'cancelled': { $sum: { $cond: [{ $eq: ['$status', 'CANCELLED'] }, 1, 0] } }, " +
    "   'completed': { $sum: { $cond: [{ $eq: ['$status', 'COMPLETED'] }, 1, 0] } }, " +
    "   'totalAdults': { $sum: '$adults' }, " +
    "   'totalChildren': { $sum: '$children' } } }",
    "{ '$project': { '_id': 0 } }"
})
Map<String, Object> getReservationStatistics(
    List<String> roomIds, LocalDate startDate, LocalDate endDate);
\end{lstlisting}

This aggregation demonstrates:
\begin{itemize}
    \item \textbf{\$match with \$in}: Filters reservations for multiple rooms efficiently.
    \item \textbf{\$group with \$cond}: Conditional counting for status-based metrics.
    \item \textbf{Date range filtering}: Uses \texttt{\$gte} and \texttt{\$lte} for inclusive date bounds.
\end{itemize}

\subsubsection{Monthly Revenue Aggregation}

Analyzing revenue trends over time for manager properties:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'roomId': { $in: ?0 }, 'status': { $ne: 'CANCELLED' }, " +
    "   'dates.checkIn': { $gte: ?1, $lte: ?2 } } }",
    "{ '$addFields': { 'yearMonth': { $dateToString: " +
    "   { format: '%Y-%m', date: '$dates.checkIn' } } } }",
    "{ '$group': { '_id': '$yearMonth', " +
    "   'revenue': { $sum: '$totalPrice' }, 'count': { $sum: 1 } } }",
    "{ '$sort': { '_id': 1 } }",
    "{ '$project': { 'month': '$_id', 'revenue': 1, 'count': 1, '_id': 0 } }"
})
List<Map<String, Object>> getMonthlyRevenueByRooms(
    List<String> roomIds, LocalDate startDate, LocalDate endDate);
\end{lstlisting}

Key techniques:
\begin{itemize}
    \item \textbf{\$dateToString}: Formats dates for grouping by month (YYYY-MM format).
    \item \textbf{Excludes cancelled}: Only counts completed/confirmed reservations for revenue.
    \item \textbf{Chronological sorting}: Enables trend visualization in dashboards.
\end{itemize}

\subsubsection{Total Revenue Calculation}

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'roomId': { $in: ?0 }, 'status': { $ne: 'CANCELLED' }, " +
    "   'dates.checkIn': { $gte: ?1, $lte: ?2 } } }",
    "{ '$group': { '_id': null, 'totalRevenue': { $sum: '$totalPrice' } } }",
    "{ '$project': { '_id': 0, 'totalRevenue': 1 } }"
})
Map<String, Object> getTotalRevenue(
    List<String> roomIds, LocalDate startDate, LocalDate endDate);
\end{lstlisting}

\subsubsection{Booking Patterns by Day of Week}

Analyzing which days receive the most bookings:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'roomId': { $in: ?0 } } }",
    "{ '$addFields': { 'dayOfWeek': { $dayOfWeek: '$dates.checkIn' } } }",
    "{ '$group': { '_id': '$dayOfWeek', 'count': { $sum: 1 } } }",
    "{ '$sort': { '_id': 1 } }",
    "{ '$project': { 'dayOfWeek': '$_id', 'count': 1, '_id': 0 } }"
})
List<Map<String, Object>> getBookingPatternsByDayOfWeek(List<String> roomIds);
\end{lstlisting}

This uses \texttt{\$dayOfWeek} to extract the day (1=Sunday, 7=Saturday) for pattern analysis.

\subsubsection{Rating Statistics for Property}

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'propertyId': ?0 } }",
    "{ '$group': { '_id': null, " +
    "   'averageRating': { $avg: '$rating' }, " +
    "   'totalReviews': { $sum: 1 }, " +
    "   'minRating': { $min: '$rating' }, " +
    "   'maxRating': { $max: '$rating' }, " +
    "   'variance': { $stdDevPop: '$rating' } } }",
    "{ '$project': { '_id': 0 } }"
})
Map<String, Object> getRatingStatistics(String propertyId);
\end{lstlisting}

This aggregation calculates comprehensive statistics including variance using \texttt{\$stdDevPop}.

\subsubsection{Rating Evolution Over Time}

Analyzing how property ratings change over time:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'propertyId': ?0, " +
    "   'creationDate': { $gte: ?1, $lte: ?2 } } }",
    "{ '$addFields': { 'yearMonth': { $dateToString: " +
    "   { format: '%Y-%m', date: '$creationDate' } } } }",
    "{ '$group': { '_id': '$yearMonth', " +
    "   'averageRating': { $avg: '$rating' }, 'count': { $sum: 1 } } }",
    "{ '$sort': { '_id': 1 } }",
    "{ '$project': { 'month': '$_id', 'averageRating': 1, 'count': 1, '_id': 0 } }"
})
List<Map<String, Object>> getMonthlyRatingEvolution(
    String propertyId, LocalDate startDate, LocalDate endDate);
\end{lstlisting}

\subsubsection{Rating Distribution}

Getting the count of reviews per rating value:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'propertyId': ?0 } }",
    "{ '$group': { '_id': '$rating', 'count': { $sum: 1 } } }",
    "{ '$sort': { '_id': 1 } }",
    "{ '$project': { 'rating': '$_id', 'count': 1, '_id': 0 } }"
})
List<Map<String, Object>> getRatingDistribution(String propertyId);
\end{lstlisting}

\subsubsection{Portfolio Rating Statistics}

Aggregate statistics across multiple properties for manager dashboard:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'propertyId': { $in: ?0 } } }",
    "{ '$group': { '_id': null, " +
    "   'overallAverageRating': { $avg: '$rating' }, " +
    "   'totalReviews': { $sum: 1 }, " +
    "   'excellentCount': { $sum: { $cond: [{ $gte: ['$rating', 4.5] }, 1, 0] } }, " +
    "   'goodCount': { $sum: { $cond: [{ $and: " +
    "       [{ $gte: ['$rating', 3.5] }, { $lt: ['$rating', 4.5] }] }, 1, 0] } }, " +
    "   'poorCount': { $sum: { $cond: [{ $lt: ['$rating', 3.5] }, 1, 0] } } } }",
    "{ '$project': { '_id': 0 } }"
})
Map<String, Object> getPortfolioRatingStatistics(List<String> propertyIds);
\end{lstlisting}

This categorizes reviews into excellent ($\geq$4.5), good (3.5-4.5), and poor ($<$3.5).

\subsubsection{Property Ratings Comparison}

Comparing ratings across multiple properties:

\begin{lstlisting}[style=javaStyle]
@Aggregation(pipeline = {
    "{ '$match': { 'propertyId': { $in: ?0 } } }",
    "{ '$group': { '_id': '$propertyId', " +
    "   'averageRating': { $avg: '$rating' }, " +
    "   'reviewCount': { $sum: 1 } } }",
    "{ '$sort': { 'averageRating': -1 } }",
    "{ '$project': { 'propertyId': '$_id', " +
    "   'averageRating': 1, 'reviewCount': 1, '_id': 0 } }"
})
List<Map<String, Object>> getPropertyRatingsComparison(List<String> propertyIds);
\end{lstlisting}

\subsection{Update Operations with @Query and @Update}

Spring Data MongoDB supports atomic update operations using the combination of \texttt{@Query} and \texttt{@Update} annotations.

\subsubsection{Update Reservation Status}

\begin{lstlisting}[style=javaStyle]
@Query("{ '_id': ?0 }")
@Update("{ '$set': { 'status': ?1 } }")
void updateStatus(String reservationId, String status);
\end{lstlisting}

\subsubsection{Cancel Reservation with User Verification}

\begin{lstlisting}[style=javaStyle]
@Query("{ '_id': ?0, 'userId': ?1 }")
@Update("{ '$set': { 'status': 'CANCELLED' } }")
long cancelReservation(String reservationId, String userId);
\end{lstlisting}

This ensures only the reservation owner can cancel, with atomic update.

\subsubsection{Update Reviewer Username}

When a user changes their username, all their reviews must be updated:

\begin{lstlisting}[style=javaStyle]
@Query("{ 'userId': ?0 }")
@Update("{ '$set': { 'reviewerUsername': ?1 } }")
void updateReviewerUsername(String userId, String newUsername);
\end{lstlisting}

\section{Neo4j Queries}

Neo4j powers the recommendation engine through graph-based queries using Cypher, Neo4j's declarative query language.

\subsection{Collaborative Filtering Recommendations}

The primary recommendation algorithm identifies properties booked by users with similar preferences:

\begin{lstlisting}[style=javaStyle]
public List<PropertyResponseDTO> getCollaborativeRecommendations(
        String propertyId) {
    
    String cypherQuery = """
        MATCH (p:Property {propertyId: $propId})<-[:BOOKED]-(u:User)
              -[:BOOKED]->(other:Property)
        RETURN other.propertyId AS recommendedId, 
               count(*) AS strength
        ORDER BY strength DESC
        LIMIT 5
    """;

    Collection<String> recommendedIds = neo4jClient.query(cypherQuery)
        .bind(propertyId).to("propId")
        .fetchAs(String.class)
        .mappedBy((typeSystem, record) -> 
            record.get("recommendedId").asString())
        .all();

    return propertyRepository.findAllById(recommendedIds);
}
\end{lstlisting}

The Cypher query pattern works as follows:
\begin{itemize}
    \item \textbf{Start node}: Finds the property being viewed.
    \item \textbf{First hop}: Traverses \texttt{BOOKED} relationships backward to find users who booked this property.
    \item \textbf{Second hop}: Traverses \texttt{BOOKED} relationships forward to find other properties these users booked.
    \item \textbf{Aggregation}: Groups by property and counts co-occurrences as "strength".
    \item \textbf{Ranking}: Orders by strength to surface the most relevant recommendations.
\end{itemize}

This implements the classic "users who booked X also booked Y" collaborative filtering pattern.

\paragraph{Domain-specific query description:}
Given a user viewing a property page, the system needs to suggest alternative properties that were popular among users with similar booking behavior. The recommendation logic follows the pattern: "Users who booked this property also booked these other properties."

\paragraph{Graph-centric query translation:}
The Cypher query exploits the graph structure to traverse booking relationships:
\begin{enumerate}
    \item Start from the target \texttt{Property} node using its \texttt{propertyId}
    \item Traverse \texttt{BOOKED} relationships \textit{backward} to reach \texttt{User} nodes who booked this property
    \item From these users, traverse \texttt{BOOKED} relationships \textit{forward} to discover other \texttt{Property} nodes they also booked
    \item Aggregate the results by counting co-occurrence frequency (strength metric)
    \item Rank by strength descending to prioritize properties with strongest collaborative signals
\end{enumerate}

This two-hop graph traversal naturally captures collaborative filtering semantics: properties frequently co-booked by the same users indicate similar appeal.

\subsection{Content-Based Filtering Recommendations}

The content-based approach finds similar properties by analyzing shared amenities:

\begin{lstlisting}[style=javaStyle]
public List<PropertyResponseDTO> getContentBasedRecommendations(
        String propertyId) {
    
    String cypherQuery = """
        MATCH (p:Property {propertyId: $propId})-[:HAS]->(a:Amenity)
              <-[:HAS]-(other:Property)
        WHERE p.propertyId <> other.propertyId
        RETURN other.propertyId AS recommendedId, 
               count(a) AS matchStrength
        ORDER BY matchStrength DESC
        LIMIT 10
    """;

    Collection<String> recommendedIds = neo4jClient.query(cypherQuery)
        .bind(propertyId).to("propId")
        .fetchAs(String.class)
        .mappedBy((typeSystem, record) -> 
            record.get("recommendedId").asString())
        .all();

    List<Property> properties = 
        (List<Property>) propertyRepository.findAllById(recommendedIds);
    
    // Preserve Neo4j ordering (highest similarity first)
    Map<String, Property> propertyMap = properties.stream()
        .collect(Collectors.toMap(Property::getId, p -> p));
    
    return recommendedIds.stream()
        .map(propertyMap::get)
        .filter(Objects::nonNull)
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}
\end{lstlisting}

The query identifies properties sharing common amenities:
\begin{itemize}
    \item \textbf{Pattern matching}: Finds amenities connected to the source property via \texttt{HAS} relationships.
    \item \textbf{Similarity discovery}: Traverses back through \texttt{HAS} relationships to find other properties with matching amenities.
    \item \textbf{Strength metric}: Counts shared amenities as a similarity score.
    \item \textbf{Self-exclusion}: Filters out the source property using \texttt{WHERE} clause.
\end{itemize}

\paragraph{Domain-specific query description:}
When a user views a property with specific features (pool, WiFi, parking, etc.), the system should recommend other properties offering similar amenities. This answers the question: "Show me properties with features similar to this one."

\paragraph{Graph-centric query translation:}
The Cypher query leverages the bipartite graph structure between Properties and Amenities:
\begin{enumerate}
    \item Start from the source \texttt{Property} node
    \item Traverse \texttt{HAS} relationships \textit{outward} to reach connected \texttt{Amenity} nodes (WiFi, Pool, Parking, etc.)
    \item From these shared amenity nodes, traverse \texttt{HAS} relationships \textit{backward} to discover other \texttt{Property} nodes
    \item Count the number of shared \texttt{Amenity} nodes as the match strength metric
    \item Filter out the source property to avoid self-recommendation
    \item Rank results by match strength descending
\end{enumerate}

This pattern-matching strategy efficiently computes feature overlap without requiring pairwise comparisons. Properties sharing more amenities naturally emerge at the top through graph traversal counting.

\subsection{Graph Constraints for Data Integrity}

The application creates constraints at startup to ensure graph integrity:

\begin{lstlisting}[style=javaStyle]
@EventListener(ApplicationReadyEvent.class)
public void createIndexesAndConstraints() {
    List<String> startupQueries = List.of(
        // Property uniqueness - O(1) lookup for recommendations
        "CREATE CONSTRAINT property_id_unique IF NOT EXISTS " +
        "FOR (p:Property) REQUIRE p.id IS UNIQUE",

        // User uniqueness - essential for collaborative filtering
        "CREATE CONSTRAINT user_id_unique IF NOT EXISTS " +
        "FOR (u:User) REQUIRE u.id IS UNIQUE",

        // Amenity uniqueness - ensures shared nodes for traversal
        "CREATE CONSTRAINT amenity_name_unique IF NOT EXISTS " +
        "FOR (a:Amenity) REQUIRE a.name IS UNIQUE"
    );

    startupQueries.forEach(query -> neo4jClient.query(query).run());
}
\end{lstlisting}

These constraints serve dual purposes:
\begin{itemize}
    \item \textbf{Data integrity}: Prevents duplicate nodes.
    \item \textbf{Performance}: Creates implicit indexes for O(1) lookups.
\end{itemize}

\section{Redis Queries and Operations}

Redis provides in-memory data structures for caching, session management, and real-time features.

\subsection{Token Blacklisting for Secure Logout}

JWT tokens are stateless by design, but the application implements secure logout through Redis blacklisting:

\begin{lstlisting}[style=javaStyle]
public void blacklistToken(String token) {
    String cleanedToken = cleanToken(token);
    Claims claims = getClaims(cleanedToken);
    
    // Calculate remaining TTL
    long tokenExpiration = claims.getExpiration().getTime();
    long currentTime = System.currentTimeMillis();
    long ttl = tokenExpiration - currentTime;

    if (ttl > 0) {
        // Key format: "blacklist:<token>"
        redisTemplate.opsForValue()
            .set("blacklist:" + cleanedToken, "true", 
                 ttl, TimeUnit.MILLISECONDS);
    }
}

private boolean isTokenBlacklisted(String token) {
    Boolean exists = redisTemplate.hasKey("blacklist:" + token);
    return exists != null && exists;
}
\end{lstlisting}

Key design decisions:
\begin{itemize}
    \item \textbf{TTL-based expiration}: Blacklist entries automatically expire when the token would have naturally expired, preventing unbounded memory growth.
    \item \textbf{String data type}: Simple key-value structure for O(1) lookup.
    \item \textbf{Validation integration}: Token validation checks blacklist before accepting requests.
\end{itemize}

\subsection{Pessimistic Locking for Reservations}

To prevent double-booking during the payment window, Redis implements temporary locks:

\begin{lstlisting}[style=javaStyle]
private static final String REDIS_PREFIX = "temp_res:";

public ReservationResponseDTO initiateReservation(
        String token, ReservationRequestDTO request) {
    
    // Check MongoDB for confirmed bookings
    List<Reservation> confirmedOverlaps = reservationRepository
        .findOverlappingReservations(room.getId(), 
            request.getCheckIn(), request.getCheckOut());
    
    if (!confirmedOverlaps.isEmpty()) {
        throw new IllegalStateException("Room already booked");
    }

    // Check Redis for temporary locks
    Set<String> keys = redisTemplate.keys(REDIS_PREFIX + "*");
    if (keys != null) {
        for (String key : keys) {
            Reservation pending = objectMapper.convertValue(
                redisTemplate.opsForValue().get(key), 
                Reservation.class);
            
            if (pending != null && 
                pending.getRoomId().equals(room.getId()) &&
                isOverlapping(pending.getDates(), 
                    request.getCheckIn(), request.getCheckOut())) {
                throw new IllegalStateException(
                    "Room being paid for. Try again in 15 mins.");
            }
        }
    }

    // Create temporary reservation with 15-minute TTL
    String tempId = UUID.randomUUID().toString();
    Reservation tempReservation = Reservation.builder()
        .id(tempId)
        .roomId(room.getId())
        .dates(new ReservationDates(
            request.getCheckIn(), request.getCheckOut()))
        .status("PENDING_PAYMENT")
        .build();

    redisTemplate.opsForValue()
        .set(REDIS_PREFIX + tempId, tempReservation, 
             15, TimeUnit.MINUTES);
    
    return mapToDTO(tempReservation);
}
\end{lstlisting}

This implements a pessimistic locking pattern:
\begin{itemize}
    \item \textbf{Temporary reservation}: Stored in Redis with 15-minute TTL during payment.
    \item \textbf{Overlap checking}: Both MongoDB (confirmed) and Redis (pending) are checked.
    \item \textbf{Automatic unlock}: TTL ensures locks are released if payment is abandoned.
\end{itemize}

\subsection{Trending Properties with Sorted Sets}

Redis sorted sets maintain real-time property popularity rankings:

\begin{lstlisting}[style=javaStyle]
// Increment view count when property is viewed
public PropertyResponseDTO getPropertyDetails(String propertyId) {
    Property property = propertyRepository.findById(propertyId)
        .orElseThrow(() -> new IllegalArgumentException("Not found"));

    // ZINCRBY trending_properties 1 <propertyId>
    redisTemplate.opsForZSet()
        .incrementScore("trending_properties", propertyId, 1);

    return mapToDTO(property);
}

// Get top 10 trending properties
public List<PropertyResponseDTO> getTrendingProperties() {
    // ZREVRANGE trending_properties 0 9
    var topIds = redisTemplate.opsForZSet()
        .reverseRange("trending_properties", 0, 9);
    
    if (topIds == null || topIds.isEmpty()) return List.of();

    List<String> ids = topIds.stream()
        .map(Object::toString)
        .collect(Collectors.toList());
    
    return propertyRepository.findAllById(ids).stream()
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}
\end{lstlisting}

Redis sorted sets provide:
\begin{itemize}
    \item \textbf{O(log N) insertion}: Efficient score updates.
    \item \textbf{O(log N + M) range queries}: Fast top-K retrieval.
    \item \textbf{Atomic operations}: Thread-safe score increments.
\end{itemize}

\subsection{User Browsing History with Lists}

Redis lists store recently viewed properties per user:

\begin{lstlisting}[style=javaStyle]
public void addToUserHistory(String userId, String propertyId) {
    String key = "history:" + userId;
    
    // LPUSH adds to front of list
    redisTemplate.opsForList().leftPush(key, propertyId);
    
    // LTRIM keeps only last 10 items
    redisTemplate.opsForList().trim(key, 0, 9);
}

public List<PropertyResponseDTO> getUserHistory(String userId) {
    String key = "history:" + userId;
    
    // LRANGE retrieves all items
    List<Object> historyIds = redisTemplate.opsForList()
        .range(key, 0, -1);
    
    if (historyIds == null || historyIds.isEmpty()) 
        return List.of();

    List<String> ids = historyIds.stream()
        .map(Object::toString)
        .collect(Collectors.toList());
    
    return propertyRepository.findAllById(ids).stream()
        .map(this::mapToDTO)
        .collect(Collectors.toList());
}
\end{lstlisting}

This pattern:
\begin{itemize}
    \item Uses \texttt{LPUSH} for O(1) insertion at head.
    \item Uses \texttt{LTRIM} to maintain fixed-size history (last 10 properties).
    \item Provides O(1) retrieval for "recently viewed" feature.
\end{itemize}

\section{Summary}

The query implementations in this chapter demonstrate how the application leverages each database technology's strengths:

\begin{itemize}
    \item \textbf{MongoDB}: Dynamic queries with \texttt{MongoTemplate} for flexible property and room search, powerful aggregation pipelines with \texttt{@Aggregation} for analytics (reservation statistics, revenue analysis, rating evolution, booking patterns), and atomic updates with \texttt{@Update} annotations.
    \item \textbf{Neo4j}: Graph traversal for collaborative filtering (users who booked X also booked Y) and content-based recommendations (properties sharing amenities), with Cypher's expressive \texttt{MATCH} patterns.
    \item \textbf{Redis}: In-memory caching with TTL for token blacklisting, pessimistic locking for reservations during payment, real-time trending rankings with sorted sets, and user browsing history with lists.
\end{itemize}

The query-driven design approach ensures that data models are optimized for the access patterns they need to support, resulting in efficient and maintainable database operations throughout the application.